#include <lcom/lcf.h>

#include <minix/syslib.h>
#include <stdint.h>

#include "8042.h"
#include "keyboard.h"

int hook_id; //Global variable that will contain the value of hook_id used to subscribe and unsubscribe the interrupts

uint32_t counterSysIn = 0; //Number of sys_inb calls
uint32_t code = 0;  //Scancode


int(kbd_test_scan_c)() {

  uint8_t irq_set = 3; //This is the number we use when we subscribe the interrupt
  if (kbd_subscribe_int(&irq_set)) {
    kbd_print_no_sysinb(counterSysIn);
    return 1;
  }

  int ipc_status, r;
  message msg;
  while (code != ESC) { //The cicle ends after the time we specify when we call the function
    /*You may want to use a different condition
        Get a request message.*/
    if ((r = driver_receive(ANY, &msg, &ipc_status)) != 0) {
      printf("driver_receive failed with: %d", r);
      continue;
    }
    if (is_ipc_notify(ipc_status)) { /* received notification */
      switch (_ENDPOINT_P(msg.m_source)) {
        case HARDWARE:                             /* hardware interrupt notification */
          if (msg.m_notify.interrupts & irq_set) { /* subscribed interrupt */

            kbc_ih(); //Counting the number of interruptions
          }
          break;
        default:
          break; /* no other notifications expected: do nothing */
      }
    }
  }

  if (kbd_unsubscribe_int()) {
    kbd_print_no_sysinb(counterSysIn);
    return 1;
  }

  kbd_print_no_sysinb(counterSysIn);
  return 0;
}

int(kbd_subscribe_int)(uint8_t *bit_no) {

  hook_id = (int) *bit_no;
  //Assigning the value of bit_no to the global variable hook_id
  //so that we can preserve bit_no when we call sys_irqsetpolicy

  if (sys_irqsetpolicy(KEYBOARD_IRQ, IRQ_REENABLE | IRQ_EXCLUSIVE, &hook_id) != OK) //Subscribing a notification on every interrupt in the input TIMER0_IRQ
    return 1;                                                                       //Value of hook_id will be used later in timer_unsubscribe_int()

  *bit_no = (uint8_t) BIT(*bit_no); //Returning the bit with number bit_no setting to 1

  return 0;
}

int(kbd_unsubscribe_int)() {

  if (sys_irqrmpolicy(&hook_id) != OK) //Unsubscribing the subscription of the interrupt notification associated with the specified hook_id
    return 1;

  return 0;
}

void kbc_ih() {
}

int(kbd_test_scan_asm)() {
  printf("%s is not yet implemented!\n", __func__);

  return 1;
}

void kbc_asm_ih() {
}

int sys_inb_cnt(port_t port, uint32_t *byte) {
  counterSysIn++;
  if (sys_inb(port, byte) != OK)
    return 1;
  return 0;
}
